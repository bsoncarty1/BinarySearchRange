# BinarySearchRange

Brandon Soncarty
CSCD 300-040 Data Structures
Prog 1 Assignment

In the original Binary Search Recursion code that we learned in class, we were looking for a single point and returning that if it existed in a given array.In that code, we used high, low, and mid variables that changed during each recursive call according to the half of the array that we wanted to search though next.

For this assignment, I took the principle of what we learned and used it in two separate methods. One method is used to find the lowest value in the array that fits the range we are given, and the other method is used to find the highest. These methods are named find_leftMost and find_rightMost respectively.

The parameters for the find_leftMost method are the array being searched, a low value, a high value, and the lowest value of the array that we are looking for (x) which is given by the user. Initially, the low will be set to 0 and the high will be set to the array length - 1. Just like in the Binary Search Recursion we learned in class, these values will change as the program runs and the recursive calls are updated. The entire body of the code for this method is placed in a while loop that will continue to run until low is greater than high, or a return statement that does not use a recursive call is run. The next operation done in the body is setting the variable mid to low+high / 2. This works just like the code we were taught in class and looks at the value that is in the middle of the array being searched. Once the mid value is set, a series of checks are done for different instances of what can occur. For the checks, I used the notes that I gathered in class. The first check is to see if the value of the mid index of the array is < 0. If it is, then the method runs the else{ statement that sets low to mid + 1 and calls the method recursively using the updated value. This is because if the value of the mid is greater than the x value, or smallest value of the range, then we know that since the array is sorted, then all the values to the left are smaller than x also, so we can search the right half of the array. If the mid value in the array is >= x, then we check to see is the value to the left of the mid index is within the bounds of the array and if the value of the index to the left of the mid is less than x. If mid - 1 is out of bounds for the array, or the value is less than x, while the mid value is >= x, then we have found the left most index of the array and we can return it out of the method. If the value at mid - 1 is in bounds and >= x, then we know that the current mid is not the left most index we are looking for. We then set the variable high to mid - 1 and use a recursive call to search the left half of the array. This will cur the number of indexes searched in the array in half like we did in class. We can do this because the array is sorted in increasing order, so we know that the values to the right are all larger than the value of x that we are searching for. If the code does not find an index in the array that fits the leftmost value given by the user, then it will run until low eventually becomes greater than high, break out of the while loop and return a value of -1 that will be used in a check later.

The parameters of the find_rightMost method are similar to the ones in the find_leftMost one above. The array being searched, initial low and high values remain the same in the call of the method, but the final parameter changes to y instead of x because we are looking for the index of the highest value in the array that fits the value given by the user in the command line. The body of this code is also similar. The first thing done is starting a while loop that runs while low <= high. If that is true, we are setting the variable mid to the value of low + high / 2 just like before. After this point in the method, the checks differ because we are looking for the right most index in the array instead of the left most. The checks are the opposite of the ones in the other method. Instead of checking if the value of the mid index is >= x, we want to see if the value is <= y. If the mid value is > y, then we know that all the values to the right of the mid index are also greater, so we set the high variable to mid - 1 and update the recursive call. If the mid value is <= y, we check to see if the index to the right of mid is out of bounds or if the value of the index to the right is > y. If either of these are false, and the mid value is <= y, then we know we have found the right most value and we return the index of mid. If both of the checks are true, then we know there is an index that is more to the right in the array that is the right most value. We can set the low variable to mid + 1 and search the right half of the array indexes recursively again. Like in the find_leftMost method, if this method doesn't find an index that fits within the value given of y by the user, then it will run until low eventually becomes greater than high. At that point it will fail the while(low <= high) check and return a value of -1.

In the main method of the program a Scanner named input is assigned to the file given by the user as args[0]. Two integer values are also set. The int variable named x is assigned to args[1] and y is assigned to args[2]. This is the order stated in the instructions that the user will give the file, lowest value, and highest value that are being searched. If all of these args are met, the program will initialize an ArrayList to initially hold the values that are in the text file. I did this because ArrayLists don't require a set size like arrays do, so I can add values to it without needing to know the exact amount of numbers that are in the file. I then start a while() loop that checks to see if the scanner in the file has a next line in it. If it does, then the number in the file is added to the ArrayList. If there are no more lines, then I know I have reached the end of the file and gathered all the values. To set up the array that will be passed into the method calls, I initialize an int array that has a length of the ArrayList.size(). After initialization, I use a for loop to add the value from each index in the ArrayList to the corresponding index in the array.

At this point the array is ready to be used and I can call the methods in the program by creating a new BinarySearchRange() object that I named test. I then use the dot operator to access the method in the class named BinarySearchRange. The BinarySearchRange method does all of the checks that were given in the instructions and if they all are true it creates two int variables. The first int variable is named 's' and it holds the value returned from the find_leftMost method call. The second int variable is named't' and it holds the value returned from the find_rightMost method. I named these variables using the examples given in the instructions for the assignment. Before s and t are returned to the main method, I check to see if either of the values are equal to -1 which would mean that one or both of the methods couldn't find an index in the array that matches the range the user is searching for. If either or both of the values are -1, then the method will return null. Otherwise, it will return a formatted String that has the left index and right index of the range in the array that the user wants. This is then returned to the main method and printed out for the user to see.

